<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chess Arena: Real-time battles between AI models</title>
    <!-- DaisyUI for UI components on top of TailwindCSS -->
    <link href="https://cdn.jsdelivr.net/npm/daisyui@3.7.3/dist/full.css" rel="stylesheet" type="text/css" />
    <!-- TailwindCSS for utility-first styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- p5.js library -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.7.0/lib/p5.min.js"></script>
    <style>
        /* p5.js Chess Board Styling */
        .chess-board-container {
            display: flex;
            justify-content: center;
            padding: 16px;
            background: #2d2d2d;
            border-radius: 8px;
            margin: 0 auto;
        }
        
        #chessBoard {
            border: 2px solid #333;
            border-radius: 4px;
        }
        
        /* Move list & commentary */
        .move-list, .commentary {
            font-family: monospace;
            white-space: pre-wrap;
            overflow-y: auto;
        }
        
        /* Make move history take full height */
        .move-history-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .move-history-content {
            flex: 1;
            overflow-y: auto;
        }
        
        /* Special effects for commentary */
        .blunder-effect {
            color: #f87272;
        }
        
        .brilliant-effect {
            color: #fbbd23;
        }
        
        /* Status message styling */
        .status-message {
            font-size: 0.85em;
            font-style: italic;
            color: #888;
            border-top: 1px solid #444;
            padding-top: 0.5em;
            margin-top: 0.5em;
        }
        
        .commentary-content {
            margin-bottom: 0.5em;
        }
        
        /* Keep fixed size - no mobile optimizations needed */
    </style>
</head>
<body class="min-h-screen bg-base-300">
    <!-- Simple header -->
    <div class="navbar bg-base-200">
        <div class="flex-1">
            <span class="font-bold text-xl px-2">AI Chess Arena<span class="hidden sm:inline text-sm font-normal text-gray-500">: Real-time battles between AI models</span></span>
        </div>
        <div class="flex-none">
            <button id="newGameBtn" class="btn btn-sm btn-primary">New Game</button>
        </div>
    </div>

    <div class="container mx-auto p-2">
        <!-- Main content -->
        <div class="grid grid-cols-1 gap-4">
            <!-- Players -->
            <div class="card bg-base-100 shadow-sm">
                <div class="stats shadow text-sm">
                    <div class="stat">
                        <div class="stat-title">⚪ White</div>
                        <div id="model1Name" class="font-medium truncate text-sm">-</div>
                    </div>
                    <div class="stat">
                        <div class="stat-title">⚫ Black</div>
                        <div id="model2Name" class="font-medium truncate text-sm">-</div>
                    </div>
                </div>
            </div>
            
            <!-- Game content -->
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <!-- Chess board section -->
                <div>
                    <div class="chess-board-container">
                        <div id="chessBoard"></div>
                    </div>
                    
                    <!-- Replay controls -->
                    <div class="flex justify-center mt-2 space-x-2" id="replayControls" style="display: none;">
                        <button class="btn btn-xs" id="replayFirst" title="First move">⏮️</button>
                        <button class="btn btn-xs" id="replayPrev" title="Previous move">⏪</button>
                        <span class="px-2 py-1 bg-gray-100 rounded text-xs font-mono" id="replayCounter">0/0</span>
                        <button class="btn btn-xs" id="replayNext" title="Next move">⏩</button>
                        <button class="btn btn-xs" id="replayLast" title="Last move">⏭️</button>
                        <button class="btn btn-xs btn-error" id="replayExit" title="Exit replay">✖️</button>
                    </div>
                </div>
                
                <!-- Info section -->
                <div class="grid grid-cols-1 gap-4 h-full">
                    <!-- Commentary -->
                    <div class="card bg-base-200 shadow-sm">
                        <div class="card-body">
                            <div class="flex justify-between items-center">
                                <h3 class="text-sm font-bold">Commentary</h3>
                                <div id="gameStatus" class="badge badge-sm font-bold bg-gray-200 text-gray-700">WAITING</div>
                            </div>
                            <div id="commentary" class="commentary text-xs mt-1">Waiting for game to start...</div>
                        </div>
                    </div>
                    
                    <!-- Moves -->
                    <div class="card bg-base-200 shadow-sm flex-1">
                        <div class="card-body move-history-container">
                            <div class="flex justify-between items-center">
                                <h3 class="text-sm font-bold">Move History</h3>
                                <button id="startReplayBtn" class="btn btn-xs btn-outline" title="Replay game" style="display: none;">▶️ Replay</button>
                            </div>
                            <div id="moveList" class="move-list text-xs mt-1 move-history-content">No moves yet</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Leaderboard (simplified) -->
            <div class="card bg-base-100 shadow-sm mt-2">
                <div class="card-body">
                    <h2 class="text-md font-bold mb-1">Leaderboard</h2>
                    <div class="overflow-x-auto">
                        <table class="table table-compact table-zebra w-full">
                            <thead>
                                <tr>
                                    <th class="text-xs">#</th>
                                    <th class="text-xs">Model</th>
                                    <th class="text-xs">Games</th>
                                    <th class="text-xs">Wins</th>
                                    <th class="text-xs">Win %</th>
                                </tr>
                            </thead>
                            <tbody id="leaderboardBody" class="text-xs">
                                <tr>
                                    <td colspan="5" class="text-center">No games yet</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            
            <!-- Hidden model selectors for future games -->
            <div class="hidden">
                <select id="model1Select"><option value="random">Random</option></select>
                <select id="model2Select"><option value="random">Random</option></select>
            </div>
        </div>
    </div>

    <!-- Toast for notifications -->
    <div id="toast" class="toast toast-end toast-bottom hidden">
        <div class="alert alert-info text-xs p-2">
            <span id="toastMessage">Message</span>
        </div>
    </div>

    <!-- Game Over Modal (simplified) -->
    <dialog id="gameOverModal" class="modal">
        <div class="modal-box p-4">
            <h3 class="font-bold text-lg">Game Over</h3>
            <p id="gameOverMessage" class="py-2 text-sm">The game has ended.</p>
            <div class="modal-action">
                <button class="btn btn-sm" onclick="document.getElementById('gameOverModal').close()">Close</button>
                <button id="playAgainBtn" class="btn btn-sm btn-primary">Play Again</button>
            </div>
        </div>
    </dialog>

    <script>
        /**
         * AI Chess Arena - Frontend JavaScript
         * 
         * This script handles all the frontend functionality for the AI Chess Arena:
         * - Initializing the chessboard and UI
         * - Managing WebSocket connections for real-time updates
         * - Rendering the chessboard with Unicode chess symbols
         * - Displaying move history and commentary
         * - Handling model selection and game controls
         * - Visual effects for special game events
         */
        
        // Global state variables
        let socket = null;              // WebSocket connection
        let currentGameId = null;       // ID of the active game
        let models = [];                // Available AI models
        let gameInProgress = false;     // Track if a game is currently being played
        let lastMove = null;            // Store the last move made for highlighting
        let gameBoard = [];             // Current state of the chess board
        let boardHistory = [];          // History of all board states for replay
        let currentHistoryIndex = -1;   // Current position in history replay
        let isReplaying = false;        // Whether we're in replay mode
        
        // p5.js variables
        let chessCanvas;
        let boardSize = 400;
        let squareSize = 50;
        let animatingPiece = null;
        let lightColor, darkColor;
        let pieces = {};

        /**
         * Initialize the application when the page loads
         */
        // Simple logging function for frontend
        function log(message, level = 'info') {
            const timestamp = new Date().toISOString();
            const logMessage = `[${timestamp}] ${level.toUpperCase()}: ${message}`;
            console.log(logMessage);
        }

        document.addEventListener('DOMContentLoaded', async () => {
            log("AI Chess Arena initializing...");
            
            // Initialize the chessboard display
            initChessBoard();
            
            // Load available models from the server
            await loadModels();
            
            // Load the leaderboard data
            await loadLeaderboard();
            
            // Set up event listeners for UI controls
            document.getElementById('newGameBtn').addEventListener('click', () => {
                if (gameInProgress) {
                    if (confirm('A game is currently in progress. Are you sure you want to start a new game?')) {
                        resetGame();
                    }
                } else {
                    resetGame();
                }
            });
            
            // Set event listeners for remaining buttons
            if (document.getElementById('startGameBtn')) {
                document.getElementById('startGameBtn').addEventListener('click', startGame);
            }
            document.getElementById('playAgainBtn').addEventListener('click', resetGame);
            
            // Set up replay controls
            document.getElementById('startReplayBtn').addEventListener('click', startReplay);
            document.getElementById('replayFirst').addEventListener('click', () => replayMove(0));
            document.getElementById('replayPrev').addEventListener('click', () => replayMove(currentHistoryIndex - 1));
            document.getElementById('replayNext').addEventListener('click', () => replayMove(currentHistoryIndex + 1));
            document.getElementById('replayLast').addEventListener('click', () => replayMove(boardHistory.length - 1));
            document.getElementById('replayExit').addEventListener('click', exitReplay);
            
            // Always start a new game automatically when the page loads
            startGame();
            log("Initialization complete, auto-starting new game");
        });
        
        /**
         * Initialize the chess board UI
         * Calls updateChessBoard with the standard initial position.
         * Ensures the board is drawn when the page loads.
         */
        /**
         * Initialize the chess board with p5.js
         */
        function initChessBoard() {
            // Create empty board state
            gameBoard = createEmptyBoard();
            
            // Set up initial position
            const initialPosition = createStandardPosition();
            updateChessBoard(initialPosition);
            log("p5.js Chessboard initialized");
        }
        
        /**
         * Create standard chess starting position
         */
        function createStandardPosition() {
            const board = createEmptyBoard();
            
            // Black pieces
            board[0] = [
                {"symbol": "♜", "color": "b"}, {"symbol": "♞", "color": "b"}, 
                {"symbol": "♝", "color": "b"}, {"symbol": "♛", "color": "b"}, 
                {"symbol": "♚", "color": "b"}, {"symbol": "♝", "color": "b"}, 
                {"symbol": "♞", "color": "b"}, {"symbol": "♜", "color": "b"}
            ];
            
            // Black pawns
            for (let col = 0; col < 8; col++) {
                board[1][col] = {"symbol": "♟", "color": "b"};
            }
            
            // White pawns
            for (let col = 0; col < 8; col++) {
                board[6][col] = {"symbol": "♟", "color": "w"};
            }
            
            // White pieces
            board[7] = [
                {"symbol": "♜", "color": "w"}, {"symbol": "♞", "color": "w"}, 
                {"symbol": "♝", "color": "w"}, {"symbol": "♛", "color": "w"}, 
                {"symbol": "♚", "color": "w"}, {"symbol": "♝", "color": "w"}, 
                {"symbol": "♞", "color": "w"}, {"symbol": "♜", "color": "w"}
            ];
            
            return board;
        }
        
        /**
         * Helper function to create an empty 8x8 chess board
         */
        function createEmptyBoard() {
            const board = [];
            for (let row = 0; row < 8; row++) {
                const boardRow = [];
                for (let col = 0; col < 8; col++) {
                    boardRow.push({"symbol": "", "color": ""});
                }
                board.push(boardRow);
            }
            return board;
        }
        
        /**
         * Load available AI models from the server
         * Fetches models from the API and populates the dropdown selectors
         */
        async function loadModels() {
            try {
                log("Fetching available models from server");
                const response = await fetch('/models');
                const data = await response.json();
                models = data.models;
                log(`${models.length} models loaded from server`);
                
                // Get references to the dropdown elements
                const model1Select = document.getElementById('model1Select');
                const model2Select = document.getElementById('model2Select');
                
                // Clear existing options except for the "Random" option (which is always first)
                while (model1Select.options.length > 1) {
                    model1Select.remove(1);
                }
                while (model2Select.options.length > 1) {
                    model2Select.remove(1);
                }
                
                // Add each model to both dropdowns
                models.forEach(model => {
                    // Use the display name from the server if available, otherwise format it
                    const displayName = model.display_name || formatModelName(model.id || model);
                    const modelId = model.id || model;
                    
                    // Create and add option for White player (model1)
                    const option1 = document.createElement('option');
                    option1.value = modelId;
                    option1.textContent = displayName;
                    model1Select.appendChild(option1);
                    
                    // Create and add option for Black player (model2)
                    const option2 = document.createElement('option');
                    option2.value = modelId;
                    option2.textContent = displayName;
                    model2Select.appendChild(option2);
                });
                
                log("Model dropdowns populated");
            } catch (error) {
                console.error("Error loading models:", error);
                showToast('Error loading models: ' + error.message);
            }
        }
        
        // Format model name for display
        function formatModelName(model) {
            if (!model) return "Unknown Model";
            
            // Check if model is an object (from old format) or string (new format)
            if (typeof model === 'object' && model.id) {
                return model.display_name || model.id;
            }
            
            // Handle string format
            let modelStr = model;
            if (modelStr.startsWith('/')) {
                modelStr = modelStr.substring(1);
            }
            
            // Split into provider and model name
            const parts = modelStr.split('/');
            if (parts.length < 2) return modelStr;
            
            let provider = parts[0];
            let name = parts[1];
            
            // Handle additional tags after the name (like :free)
            if (name.includes(':')) {
                const nameParts = name.split(':');
                name = nameParts[0];
            }
            
            return `${provider} / ${name}`;
        }
        
        // Format model name for player titles (drops mistralai prefix)
        function formatPlayerName(model) {
            if (!model) return "Unknown Model";
            
            // Check if model is an object (from old format) or string (new format)
            if (typeof model === 'object' && model.id) {
                model = model.display_name || model.id;
            }
            
            // Handle string format
            let modelStr = model;
            if (modelStr.startsWith('/')) {
                modelStr = modelStr.substring(1);
            }
            
            // Split into provider and model name
            const parts = modelStr.split('/');
            if (parts.length < 2) return modelStr;
            
            let provider = parts[0];
            let name = parts[1];
            
            // Handle additional tags after the name (like :free)
            if (name.includes(':')) {
                const nameParts = name.split(':');
                name = nameParts[0];
            }
            
            // Drop mistralai prefix for player titles
            if (provider.toLowerCase() === 'mistralai') {
                return name;
            }
            
            return `${provider} / ${name}`;
        }
        
        // Load leaderboard data
        async function loadLeaderboard() {
            try {
                const response = await fetch('/leaderboard');
                const data = await response.json();
                updateLeaderboard(data.leaderboard);
            } catch (error) {
                showToast('Error loading leaderboard: ' + error.message);
            }
        }
        
        // Update leaderboard display - simplified for mobile
        function updateLeaderboard(leaderboard) {
            const tbody = document.getElementById('leaderboardBody');
            tbody.innerHTML = '';
            
            if (leaderboard.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="5" class="text-center">No games yet</td>';
                tbody.appendChild(row);
                return;
            }
            
            // Show full leaderboard
            leaderboard.forEach((entry, index) => {
                const row = document.createElement('tr');
                
                // Add rank class for top 3
                if (index < 3) {
                    row.classList.add('font-bold');
                }
                
                // Allow longer model names in leaderboard
                let displayName = entry.display_name || formatModelName(entry.model);
                // Shorten if too long (3x longer than before)
                if (displayName.length > 60) {
                    displayName = displayName.substring(0, 58) + '...';
                }
                
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${displayName}</td>
                    <td>${entry.games}</td>
                    <td>${entry.wins}</td>
                    <td>${entry.win_rate}%</td>
                `;
                
                tbody.appendChild(row);
            });
        }
        
        // Start a new game
        async function startGame() {
            if (gameInProgress) {
                resetGame();
            }
            
            try {
                const model1 = document.getElementById('model1Select').value;
                const model2 = document.getElementById('model2Select').value;
                
                // Update UI
                document.getElementById('gameStatus').textContent = 'STARTING...';
                document.getElementById('gameStatus').className = 'badge badge-sm font-bold bg-yellow-500 text-white';
                document.getElementById('model1Name').textContent = model1 === 'random' ? 'Random Model' : formatPlayerName(model1);
                document.getElementById('model2Name').textContent = model2 === 'random' ? 'Random Model' : formatPlayerName(model2);
                document.getElementById('commentary').textContent = 'Setting up the game...';
                document.getElementById('moveList').textContent = 'No moves yet';
                
                // Create game
                const response = await fetch('/games', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model1, model2 })
                });
                
                const data = await response.json();
                currentGameId = data.game_id;
                
                // Connect to WebSocket
                connectWebSocket(currentGameId);
                gameInProgress = true;
            } catch (error) {
                showToast('Error starting game: ' + error.message);
                document.getElementById('gameStatus').textContent = 'Error';
                document.getElementById('gameStatus').className = 'badge badge-lg badge-error';
            }
        }
        
        /**
         * Connect to WebSocket for real-time game updates
         * 
         * This function establishes a WebSocket connection to the server to receive
         * live updates about the game in progress, including moves, commentary, and game state.
         * 
         * @param {string} gameId - The ID of the game to connect to
         */
        function connectWebSocket(gameId) {
            // Close any existing connection before creating a new one
            if (socket) {
                socket.close();
            }
            
            // Determine the appropriate WebSocket protocol based on page protocol (HTTP/HTTPS)
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/${gameId}`;
            
            log(`Connecting to WebSocket at ${wsUrl}`);
            socket = new WebSocket(wsUrl);
            
            // Connection established handler
            socket.onopen = () => {
                log('WebSocket connected successfully');
            };
            
            // Message received handler
            socket.onmessage = (event) => {
                const message = JSON.parse(event.data);
                log("WebSocket message received: " + message.type);
                handleWebSocketMessage(message);
            };
            
            // Connection closed handler
            socket.onclose = () => {
                log('WebSocket connection closed');
            };
            
            // Error handler
            socket.onerror = (error) => {
                console.error('WebSocket error:', error);
                showToast('Connection error: ' + error.message);
            };
        }
        
        /**
         * Handle messages received through the WebSocket connection
         * 
         * This function processes different types of messages from the server:
         * - game_state: Updates to the overall game state
         * - move_made: A new move has been made
         * - status_update: Status messages about the game
         * - game_over: The game has ended
         * - error: Error messages
         * - commentary_update: Commentary from GPT-4.1-mini
         * 
         * @param {Object} message - The parsed message received from the server
         */
        function handleWebSocketMessage(message) {
            log('Received WebSocket message: ' + message.type);
            
            switch (message.type) {
                case 'game_state':
                    // Store the board state in history for replay
                    if (!isReplaying && message.data.board) {
                        boardHistory.push(JSON.parse(JSON.stringify(message.data.board)));
                        currentHistoryIndex = boardHistory.length - 1;
                        
                        // Enable replay button if we have moves
                        if (boardHistory.length > 1) {
                            document.getElementById('startReplayBtn').disabled = false;
                        }
                    }
                    
                    // Update the UI with the current game state
                    updateGameState(message.data);
                    break;
                    
                case 'move_made':
                    // Handle a move being made by one of the AI models
                    handleMoveMade(message.data);
                    break;
                    
                case 'status_update':
                    // Update status messages (e.g., "Waiting for model to move...")
                    // If we have both status message and commentary, display both
                    if (message.data.commentary && message.data.commentary !== "Analyzing move...") {
                        // Show both commentary and status message
                        const statusHtml = `<div class="commentary-content">${highlightChessAnnotations(message.data.commentary)}</div>
                                          <div class="status-message text-info mt-2">${message.data.message}</div>`;
                        document.getElementById('commentary').innerHTML = statusHtml;
                    } else {
                        // Just show the status message
                        document.getElementById('commentary').innerHTML = highlightChessAnnotations(message.data.message);
                    }
                    break;
                    
                case 'game_over':
                    // Handle game completion
                    handleGameOver(message.data);
                    break;
                    
                case 'error':
                    // Display error messages
                    showToast('Error: ' + message.data.message);
                    break;
                    
                case 'commentary_update':
                    // Handle asynchronous commentary updates from GPT-4.1-mini
                    if (message.data && message.data.commentary) {
                        // If we have both status message and commentary, display both
                        if (message.data.message) {
                            // Show both commentary and status message
                            const statusHtml = `<div class="commentary-content">${highlightChessAnnotations(message.data.commentary)}</div>
                                              <div class="status-message text-info mt-2">${message.data.message}</div>`;
                            document.getElementById('commentary').innerHTML = statusHtml;
                        } else {
                            // Just show the commentary with highlighting
                            document.getElementById('commentary').innerHTML = highlightChessAnnotations(message.data.commentary);
                        }
                        
                        // Apply visual effects based on commentary content (like animations for blunders)
                        applyCommentaryEffects(message.data.commentary);
                    }
                    break;
                    
                default:
                    console.warn(`Unknown message type received: ${message.type}`);
            }
        }
        
        // Update the game state display
        function updateGameState(data) {
            // Update player names if they've been selected randomly
            document.getElementById('model1Name').textContent = formatPlayerName(data.model1);
            document.getElementById('model2Name').textContent = formatPlayerName(data.model2);
            
            // Update game status with colors matching player colors (white/black)
            let statusText = 'In Progress';
            let statusClass = 'badge badge-sm badge-info';
            
            if (data.status === 'finished') {
                statusText = 'GAME OVER';
                statusClass = 'badge badge-sm badge-neutral font-bold';
            } else if (data.current_player === 0) {
                // White's turn - use white background with dark text
                statusText = 'WHITE to Move';
                statusClass = 'badge badge-sm font-bold bg-white text-black border border-gray-300';
            } else {
                // Black's turn - use black background with white text
                statusText = 'BLACK to Move';
                statusClass = 'badge badge-sm font-bold bg-black text-white';
            }
            
            document.getElementById('gameStatus').textContent = statusText;
            document.getElementById('gameStatus').className = statusClass;
            
            // Update chess board
            updateChessBoard(data.board);
            
            // Update move list (replace all moves with full game state)
            if (data.moves && data.moves.length > 0) {
                updateMoveList(data.moves, null, null, true);
            }
            
            // Update commentary
            if (data.commentary && data.commentary.length > 0) {
                document.getElementById('commentary').innerHTML = data.commentary[data.commentary.length - 1];
            }
        }
        
        /**
         * Update the chess board state (p5.js will handle rendering)
         */
        function updateChessBoard(board) {
            if (!board || !Array.isArray(board) || board.length === 0) {
                board = createEmptyBoard();
            }
            
            // Don't update board during animation
            if (animatingPiece) {
                window.pendingBoardUpdate = board;
                log('Board update delayed - animation in progress');
                return;
            }
            
            gameBoard = normalizeBoard(board);
            log('Board updated, p5.js will redraw');
        }
        
        /**
         * p5.js setup function
         */
        function setup() {
            chessCanvas = createCanvas(boardSize, boardSize);
            chessCanvas.parent('chessBoard');
            
            // Define colors
            lightColor = color(240, 217, 181); // #f0d9b5
            darkColor = color(181, 136, 99);   // #b58863
            
            // Initialize with standard position
            gameBoard = createStandardPosition();
        }
        
        /**
         * p5.js draw function - renders every frame
         */
        function draw() {
            background(45, 45, 45); // Dark background
            
            // Draw the board squares
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    // Determine square color (a1 should be dark)
                    if ((row + col) % 2 === 1) {
                        fill(darkColor);
                    } else {
                        fill(lightColor);
                    }
                    
                    // Draw square
                    rect(col * squareSize, row * squareSize, squareSize, squareSize);
                    
                    // Draw piece if present
                    const piece = gameBoard[row][col];
                    if (piece && piece.symbol) {
                        // Set piece color based on piece.color
                        if (piece.color === 'w') {
                            fill(255); // White pieces
                            stroke(0);
                            strokeWeight(1);
                        } else {
                            fill(0); // Black pieces
                            noStroke();
                        }
                        
                        textAlign(CENTER, CENTER);
                        textSize(32);
                        text(piece.symbol, 
                             col * squareSize + squareSize/2, 
                             row * squareSize + squareSize/2);
                        
                        noStroke(); // Reset stroke
                    }
                }
            }
            
            // Draw coordinates
            drawCoordinates();
            
            // Handle move animation
            if (animatingPiece) {
                drawAnimatingPiece();
            }
        }
        
        /**
         * Draw coordinate labels
         */
        function drawCoordinates() {
            fill(200); // Light gray
            textAlign(CENTER, CENTER);
            textSize(12);
            
            // File labels (a-h) at bottom
            for (let col = 0; col < 8; col++) {
                text(String.fromCharCode(97 + col), 
                     col * squareSize + squareSize/2, 
                     boardSize + 15);
            }
            
            // Rank labels (8-1) on right
            textAlign(LEFT, CENTER);
            for (let row = 0; row < 8; row++) {
                text(8 - row, 
                     boardSize + 5, 
                     row * squareSize + squareSize/2);
            }
        }
        
        /**
         * Simplified board normalization
         */
        function normalizeBoard(board) {
            const normalized = createEmptyBoard();
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row] && board[row][col]) {
                        const piece = board[row][col];
                        
                        // Handle different piece formats
                        let symbol = '';
                        let color = '';
                        
                        if (typeof piece === 'string') {
                            symbol = piece;
                        } else if (typeof piece === 'object' && piece !== null) {
                            symbol = piece.symbol || '';
                            color = piece.color || '';
                        }
                        
                        // Only add piece if it has a valid symbol
                        if (symbol && typeof symbol === 'string') {
                            normalized[row][col] = {
                                symbol: symbol,
                                color: color
                            };
                        }
                    }
                }
            }
            
            return normalized;
        }
        
        
        
        // Handle a move being made
        function handleMoveMade(data) {
            // Update move list
            updateMoveList([data.move], [data.raw_move], [data.interpreted]);
            
            // Store the last move and trigger animation
            if (data.move && data.move.length >= 4) {
                lastMove = data.move;
                log("Last move set to: " + lastMove);
                
                // Trigger p5.js animation BEFORE the board gets updated
                triggerMoveAnimationWithMove(data.move);
            }
            
            // Add visual highlight to commentary
            const commentary = data.commentary || '';
            const highlightedCommentary = highlightChessAnnotations(commentary);
            document.getElementById('commentary').innerHTML = highlightedCommentary;
            
            // Apply any visual effects (simplified - no confetti)
            applyCommentaryEffects(commentary);
            
            // Show toast if move was interpreted
            if (data.interpreted) {
                showToast(`Move interpreted: "${data.raw_move}" → "${data.move}"`, 'info', 4000);
            }
        }
        
        // Apply simpler visual effects based on commentary text
        function applyCommentaryEffects(commentary) {
            if (!commentary) return;
            
            const commentaryElement = document.getElementById('commentary');
            
            // Reset previous effects
            commentaryElement.classList.remove('blunder-effect', 'brilliant-effect');
            
            if (commentary.includes('??') || commentary.includes('blunder')) {
                // Blunder effect - add red text
                commentaryElement.classList.add('blunder-effect');
            } else if (commentary.includes('!!') || commentary.includes('brilliant')) {
                // Brilliant move effect - add gold text
                commentaryElement.classList.add('brilliant-effect');
            }
            // Removed confetti effects since we're using p5.js now
        }
        
        // Handle game over event
        function handleGameOver(data) {
            gameInProgress = false;
            
            let winner = '';
            let result = '';
            let friendlyExplanation = data.friendly_reason || '';
            
            if (data.result.result === 'win') {
                winner = formatPlayerName(data.result.winner_model);
                result = `<strong>${winner}</strong> won the game!`;
            } else if (data.result.result === 'draw') {
                result = `Game ended in a draw.`;
            } else {
                result = `Game ended unexpectedly.`;
            }
            
            // If we have a friendly explanation, use it; otherwise, use a technical reason
            let explanation = friendlyExplanation || `Technical reason: ${data.result.reason || 'unknown'}`;
            
            // Create a more informative and user-friendly message
            let message = `${result}<br><br>${explanation}`;
            
            // Update UI
            document.getElementById('gameStatus').textContent = 'GAME OVER';
            document.getElementById('gameStatus').className = 'badge badge-sm badge-neutral font-bold';
            
            // Show game over modal with formatted message
            document.getElementById('gameOverMessage').innerHTML = message;
            document.getElementById('gameOverModal').showModal();
            
            // Show replay button now that the game is over
            if (boardHistory.length > 1) {
                document.getElementById('startReplayBtn').style.display = 'block';
            }
            
            // Reload leaderboard
            loadLeaderboard();
        }
        
        // Update the move list display
        function updateMoveList(moves, rawMoves, interpreted, replaceAll = false) {
            const moveList = document.getElementById('moveList');
            
            if (!moves || moves.length === 0) {
                moveList.textContent = 'No moves yet';
                return;
            }
            
            // If replacing all moves or this is the first move, clear everything
            if (replaceAll || moveList.textContent === 'No moves yet') {
                moveList.innerHTML = '';
            }
            
            // Ensure parameters are arrays even if a single move is passed
            const moveArray = Array.isArray(moves) ? moves : [moves];
            let rawArray = Array.isArray(rawMoves) ? rawMoves : (rawMoves ? [rawMoves] : null); 
            let interpretedArray = Array.isArray(interpreted) ? interpreted : (interpreted ? [interpreted] : null);
            
            // Add each move to the list
            moveArray.forEach((move, i) => {
                const moveNumber = Math.floor((document.querySelectorAll('.move-entry').length + i) / 2) + 1;
                const isWhiteMove = (document.querySelectorAll('.move-entry').length + i) % 2 === 0;
                
                // Format the move display with raw version if interpreted
                let moveDisplay = move;
                if (rawArray && rawArray[i] && interpretedArray && interpretedArray[i]) {
                    moveDisplay = `${move} <span class="text-xs text-gray-500" title="Original input: ${rawArray[i]}">(interpreted)</span>`;
                }
                
                const moveEntry = document.createElement('div');
                moveEntry.classList.add('move-entry');
                
                if (isWhiteMove) {
                    moveEntry.innerHTML = `<strong>${moveNumber}.</strong> ${moveDisplay}`;
                } else {
                    // For black's move, append to the previous entry if it exists
                    const lastEntry = moveList.lastElementChild;
                    if (lastEntry && lastEntry.classList.contains('move-entry')) {
                        lastEntry.innerHTML += ` ${moveDisplay}`;
                        return;
                    } else {
                        moveEntry.innerHTML = `<strong>${moveNumber}...</strong> ${moveDisplay}`;
                    }
                }
                
                moveList.appendChild(moveEntry);
            });
            
            // Scroll to bottom
            moveList.scrollTop = moveList.scrollHeight;
        }
        
        // Reset the game
        function resetGame() {
            if (socket) {
                socket.close();
            }
            
            gameInProgress = false;
            currentGameId = null;
            lastMove = null;
            
            // Clear replay history
            clearReplayHistory();
            
            // Close modal if it's open
            try {
                document.getElementById('gameOverModal').close();
            } catch (e) {
                log("Modal was not open", "debug");
            }
            
            // Reset UI
            initChessBoard();
            document.getElementById('gameStatus').textContent = 'WAITING';
            document.getElementById('gameStatus').className = 'badge badge-sm font-bold bg-gray-200 text-gray-700';
            document.getElementById('model1Name').textContent = '-';
            document.getElementById('model2Name').textContent = '-';
            document.getElementById('commentary').textContent = 'Waiting for game to start...';
            document.getElementById('moveList').textContent = 'No moves yet';
            
            // Hide replay button
            document.getElementById('startReplayBtn').style.display = 'none';
            
            // Show toast to indicate a new game is starting
            showToast('Starting a new game...', 'success');
            
            // Start a new game (with a slight delay to ensure UI updates first)
            setTimeout(() => {
                startGame();
            }, 100);
        }
        
        // Replay functionality
        function startReplay() {
            if (boardHistory.length <= 1) {
                showToast('Not enough moves to replay', 'warning');
                return;
            }
            
            isReplaying = true;
            
            // Show replay controls
            document.getElementById('replayControls').style.display = 'flex';
            document.getElementById('startReplayBtn').disabled = true;
            
            // Start at the beginning
            replayMove(0);
            
            showToast('Replay mode started', 'info');
        }
        
        function replayMove(index) {
            // Validate index bounds
            if (index < 0) index = 0;
            if (index >= boardHistory.length) index = boardHistory.length - 1;
            
            // Update the current index
            currentHistoryIndex = index;
            
            // Update counter display
            document.getElementById('replayCounter').textContent = `${currentHistoryIndex + 1}/${boardHistory.length}`;
            
            // Display the board state at this index
            const boardState = boardHistory[currentHistoryIndex];
            updateChessBoard(boardState);
            
            // Disable/enable navigation buttons based on position
            document.getElementById('replayFirst').disabled = (currentHistoryIndex === 0);
            document.getElementById('replayPrev').disabled = (currentHistoryIndex === 0);
            document.getElementById('replayNext').disabled = (currentHistoryIndex === boardHistory.length - 1);
            document.getElementById('replayLast').disabled = (currentHistoryIndex === boardHistory.length - 1);
        }
        
        function exitReplay() {
            isReplaying = false;
            
            // Hide replay controls
            document.getElementById('replayControls').style.display = 'none';
            document.getElementById('startReplayBtn').disabled = false;
            
            // Return to the latest board state
            currentHistoryIndex = boardHistory.length - 1;
            updateChessBoard(boardHistory[currentHistoryIndex]);
            
            showToast('Exited replay mode', 'info');
        }
        
        // Clear replay history when a new game starts
        function clearReplayHistory() {
            boardHistory = [];
            currentHistoryIndex = -1;
            isReplaying = false;
            document.getElementById('replayControls').style.display = 'none';
            document.getElementById('startReplayBtn').disabled = true;
        }
        
        // Show a toast message
        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            
            // Set the message
            toastMessage.textContent = message;
            
            // Set the alert type
            const alertElement = toast.querySelector('.alert');
            alertElement.className = 'alert'; // Reset class
            
            switch (type) {
                case 'success':
                    alertElement.classList.add('alert-success');
                    break;
                case 'warning':
                    alertElement.classList.add('alert-warning');
                    break;
                case 'error':
                    alertElement.classList.add('alert-error');
                    break;
                case 'info':
                default:
                    alertElement.classList.add('alert-info');
                    break;
            }
            
            // Show the toast
            toast.classList.remove('hidden');
            
            // Hide after duration
            setTimeout(() => {
                toast.classList.add('hidden');
            }, duration);
        }
        
        // Highlight chess annotation symbols in commentary
        function highlightChessAnnotations(text) {
            if (!text || typeof text !== 'string') return text;
            
            // Skip if already processed (contains HTML tags)
            if (text.includes('<span')) return text;
            
            const annotations = [
                // Order matters: longer patterns first to avoid partial matches
                ['!!', '✨'],    // Brilliant move
                ['??', '💥'],    // Blunder
                ['!?', '🤔'],    // Interesting move
                ['?!', '⚠️'],    // Questionable move
                ['!', '✅'],     // Good move
                ['?', '❓'],     // Mistake
                ['□', '💡'],     // With the idea
                ['⊕', '⚔️'],     // With an attack
                ['∞', '🌀'],     // Unclear position
                ['=', '⚖️'],     // Equal position
                ['±', '📈'],     // White has a slight advantage
                ['∓', '📉'],     // Black has a slight advantage
                ['+−', '🔥'],    // White has a decisive advantage
                ['−+', '❄️'],    // Black has a decisive advantage
                ['+', '👑'],     // Check
                ['#', '🏆']      // Checkmate
            ];
            
            let result = text;
            
            // Replace annotation symbols with emojis
            for (const [symbol, emoji] of annotations) {
                // Use word boundaries and exact matches to avoid partial replacements
                const escapedSymbol = symbol.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                const regex = new RegExp(`\\b${escapedSymbol}\\b|(?<=\\s)${escapedSymbol}(?=\\s)|(?<=\\s)${escapedSymbol}$|^${escapedSymbol}(?=\\s)|^${escapedSymbol}$`, 'g');
                result = result.replace(regex, emoji);
            }
            
            return result;
        }
        
        /**
         * Animate piece movement with p5.js
         */
        function animateMove(fromSquare, toSquare, piece) {
            if (!fromSquare || !toSquare || !piece) return;
            
            const fromCoords = algebraicToCoords(fromSquare);
            const toCoords = algebraicToCoords(toSquare);
            
            // Set up animation
            animatingPiece = {
                symbol: piece.symbol,
                color: piece.color,
                fromX: fromCoords.col * squareSize + squareSize/2,
                fromY: fromCoords.row * squareSize + squareSize/2,
                toX: toCoords.col * squareSize + squareSize/2,
                toY: toCoords.row * squareSize + squareSize/2,
                currentX: fromCoords.col * squareSize + squareSize/2,
                currentY: fromCoords.row * squareSize + squareSize/2,
                progress: 0,
                duration: 45, // frames (smoother animation)
                fromSquare: fromSquare,
                toSquare: toSquare
            };
            
            // Clear the piece from the from square during animation
            gameBoard[fromCoords.row][fromCoords.col] = {symbol: '', color: ''};
        }
        
        /**
         * Draw the animating piece
         */
        function drawAnimatingPiece() {
            if (!animatingPiece) return;
            
            // Update animation progress
            animatingPiece.progress += 1;
            
            // Calculate current position using easeIn animation
            const t = animatingPiece.progress / animatingPiece.duration;
            const easedT = easeInOutCubic(t);
            
            animatingPiece.currentX = lerp(animatingPiece.fromX, animatingPiece.toX, easedT);
            animatingPiece.currentY = lerp(animatingPiece.fromY, animatingPiece.toY, easedT);
            
            // Draw the moving piece with proper color
            if (animatingPiece.color === 'w') {
                fill(255); // White pieces
                stroke(0);
                strokeWeight(1);
            } else {
                fill(0); // Black pieces
                noStroke();
            }
            
            textAlign(CENTER, CENTER);
            textSize(32);
            text(animatingPiece.symbol, animatingPiece.currentX, animatingPiece.currentY);
            
            noStroke(); // Reset stroke
            
            // End animation
            if (animatingPiece.progress >= animatingPiece.duration) {
                const toCoords = algebraicToCoords(animatingPiece.toSquare);
                gameBoard[toCoords.row][toCoords.col] = {
                    symbol: animatingPiece.symbol,
                    color: animatingPiece.color
                };
                animatingPiece = null;
                log("Animation completed");
                
                // Update board with any pending changes after animation
                if (window.pendingBoardUpdate) {
                    gameBoard = normalizeBoard(window.pendingBoardUpdate);
                    window.pendingBoardUpdate = null;
                    log('Applied pending board update after animation');
                }
            }
        }
        
        /**
         * Easing functions for smooth animation
         */
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }
        
        function easeInCubic(t) {
            return t * t * t;
        }
        
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        /**
         * Convert algebraic notation to coordinates
         */
        function algebraicToCoords(square) {
            const file = square.charCodeAt(0) - 97;
            const rank = 8 - parseInt(square[1]);
            return { row: rank, col: file };
        }
        
        /**
         * Trigger move animation when a move is made
         */
        function triggerMoveAnimation() {
            if (!lastMove || lastMove.length < 4) return;
            
            const fromSquare = lastMove.substring(0, 2);
            const toSquare = lastMove.substring(2, 4);
            const fromCoords = algebraicToCoords(fromSquare);
            
            const piece = gameBoard[fromCoords.row][fromCoords.col];
            if (piece && piece.symbol) {
                animateMove(fromSquare, toSquare, piece);
            }
        }
        
        /**
         * Trigger move animation with move data before board update
         */
        function triggerMoveAnimationWithMove(move) {
            if (!move || move.length < 4) return;
            
            const fromSquare = move.substring(0, 2);
            const toSquare = move.substring(2, 4);
            const fromCoords = algebraicToCoords(fromSquare);
            
            // Get the piece from current board before it gets updated
            const piece = gameBoard[fromCoords.row] && gameBoard[fromCoords.row][fromCoords.col];
            if (piece && piece.symbol) {
                log("Starting animation for piece: " + piece.symbol + " from " + fromSquare + " to " + toSquare);
                animateMove(fromSquare, toSquare, piece);
            } else {
                log("No piece found at " + fromSquare + " to animate");
            }
        }
    </script>
</body>
</html>